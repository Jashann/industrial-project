<!DOCTYPE html>
<html>
  <head>
    <title>Road Safety Demo with Suggestions</title>
    <meta charset="UTF-8" />
    <link
      href="https://fonts.googleapis.com/css?family=Poppins:400,700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <!-- Ionicons -->
    <script
      type="module"
      src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"
    ></script>
    <script
      nomodule
      src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"
    ></script>
    <style>
      /* General Page Styles */
      body {
        margin: 0;
        padding: 0;
        background: #f4f6f8;
        font-family: "Poppins", sans-serif;
      }
      /* Map container */
      #map {
        height: 100vh;
      }
      /* Search Container */
      #search-container {
        position: absolute;
        top: 20px;
        left: 60px;
        background: #fff;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        z-index: 1000;
        width: 280px;
      }
      #location-input {
        width: 95%;
        display: inline-block;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
        margin-bottom: 10px;
        outline: none;
        transition: border-color 0.3s;
      }
      #location-input:focus {
        border-color: #aaa;
      }
      /* Search Button */
      button {
        outline: none;
        border: none;
        font-family: inherit;
      }
      button ion-icon {
        font-size: 18px;
      }
      .flex-center {
        display: flex;
        justify-content: center;
        align-items: center;
      }
      #search-btn {
        width: 100%;
        padding: 10px;
        background: linear-gradient(135deg, #667eea, #0280e7);
        color: #fff;
        border-radius: 8px;
        font-size: 14px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 5px;
        transition: background 0.3s, box-shadow 0.3s;
      }
      #search-btn:hover {
        background: linear-gradient(135deg, #5a67d8, #6b46c1);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }
      /* Buttons Container */
      .btns-left-top {
        position: fixed;
        top: 20px;
        right: 20px;
        display: flex;
        flex-direction: row;
        gap: 10px;
        z-index: 1100;
      }
      /* Common Button Styles within the Container */
      .btns-left-top button {
        padding: 10px 15px;
        color: #fff;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        display: inline-flex;
        align-items: center;
        gap: 5px;
        transition: background 0.3s, box-shadow 0.3s, width 0.3s;
        width: 50px;
        overflow: hidden;
        white-space: nowrap;
      }
      .btns-left-top button ion-icon {
        font-size: 18px;
        margin-top: 5px;
      }
      .btns-left-top button span {
        opacity: 0;
        transition: opacity 0.2s;
        margin-left: 5px;
        white-space: nowrap;
        display: none;
      }
      .btns-left-top button:hover {
        width: 150px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }
      .btns-left-top button:hover span {
        opacity: 1;
        display: block;
      }
      /* Individual Button Backgrounds */
      .btn-download {
        background: linear-gradient(135deg, #48bb78, #38a169);
      }
      .btn-download:hover {
        background: linear-gradient(135deg, #38a169, #2f855a);
      }
      .btn-export,
      .btn-import {
        background: linear-gradient(135deg, #f6ad55, #ed8936);
      }
      .btn-export:hover,
      .btn-import:hover {
        background: linear-gradient(135deg, #ed8936, #dd6b20);
      }
      .btn-select {
        background: linear-gradient(135deg, #8e44ad, #9b59b6);
      }
      .btn-select:hover {
        background: linear-gradient(135deg, #9b59b6, #8e44ad);
      }
      .btn-finish {
        background: linear-gradient(135deg, #e74c3c, #c0392b);
      }
      #finish-area-btn {
        display: none;
      }
      .btn-finish:hover {
        background: linear-gradient(135deg, #c0392b, #e74c3c);
      }
      /* Suggestions Dropdown */
      #suggestions {
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 4px;
        max-height: 200px;
        overflow-y: auto;
        position: absolute;
        top: 65px;
        left: 15px;
        right: 15px;
        z-index: 1001;
        display: none;
      }
      .suggestion-item {
        padding: 10px;
        cursor: pointer;
        border-bottom: 1px solid #eee;
      }
      .suggestion-item:last-child {
        border-bottom: none;
      }
      .suggestion-item:hover {
        background: #f1f1f1;
      }
      /* Vector visualization styles */
      .highlighted-marker {
        filter: drop-shadow(0 0 10px yellow);
        transform: scale(1.2);
      }
      .vector-label div, .warning-label div {
        font-size: 12px;
        white-space: nowrap;
        box-shadow: 0 0 5px rgba(0,0,0,0.3);
      }
      
      /* Visualization Controls Panel */
      #visualization-controls {
        position: absolute;
        bottom: 20px;
        right: 20px;
        background: white;
        padding: 10px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        z-index: 1000;
      }
      #visualization-controls h3 {
        margin: 0 0 10px 0;
        font-size: 14px;
        text-align: center;
      }
      .viz-control-item {
        display: flex;
        align-items: center;
        margin-bottom: 6px;
      }
      .viz-control-item label {
        margin-left: 5px;
        font-size: 12px;
      }
      /* Custom Modal Styles */
      .custom-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 2000;
      }
      .custom-modal-content {
        background: #fff;
        padding: 20px 30px;
        border-radius: 8px;
        text-align: center;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        max-width: 90%;
      }
      .custom-modal-buttons {
        margin-top: 20px;
        display: flex;
        justify-content: center;
        gap: 10px;
      }
      .custom-modal-buttons button {
        padding: 8px 16px;
        border-radius: 8px;
        font-size: 14px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 5px;
        transition: background 0.3s, box-shadow 0.3s;
      }
      /* Specific Modal Button Colors */
      #custom-confirm-yes, #polygon-view-btn {
        background: linear-gradient(135deg, #28a745, #218838);
        color: #fff;
      }
      #custom-confirm-yes:hover, #polygon-view-btn:hover {
        background: linear-gradient(135deg, #218838, #1e7e34);
      }
      #custom-confirm-no {
        background: linear-gradient(135deg, #dc3545, #c82333);
        color: #fff;
      }
      #custom-confirm-no:hover {
        background: linear-gradient(135deg, #c82333, #bd2130);
      }
      #action-drag {
        background: linear-gradient(135deg, #17a2b8, #138496);
        color: #fff;
      }
      #action-drag:hover {
        background: linear-gradient(135deg, #138496, #117a8b);
      }
      #action-delete, #polygon-unselect-btn {
        background: linear-gradient(135deg, #dc3545, #c82333);
        color: #fff;
      }
      #action-delete:hover, #polygon-unselect-btn:hover {
        background: linear-gradient(135deg, #c82333, #bd2130);
      }
      #action-rename, #polygon-copy-btn {
        background: linear-gradient(135deg, #f6ad55, #ed8936);
        color: #fff;
      }
      #action-rename:hover, #polygon-copy-btn:hover {
        background: linear-gradient(135deg, #ed8936, #dd6b20);
      }
      #action-cancel {
        background: linear-gradient(135deg, #6c757d, #5a6268);
        color: #fff;
      }
      #action-cancel:hover {
        background: linear-gradient(135deg, #5a6268, #545b62);
      }
      /* Custom Rename Modal Styles */
      #custom-rename-modal input {
        width: 100%;
        padding: 8px;
        margin-top: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <div id="search-container">
      <input type="text" id="location-input" placeholder="Enter location" />
      <div id="suggestions"></div>
      <button id="search-btn">
        <ion-icon name="search-outline"></ion-icon> Search
      </button>
    </div>
    <div id="map"></div>
    
    <!-- Visualization Controls Panel -->
    <div id="visualization-controls">
      <h3>Visualization Controls</h3>
      <div class="viz-control-item">
        <input type="checkbox" id="show-vectors" checked>
        <label for="show-vectors">Show Direction Vectors</label>
      </div>
      <div class="viz-control-item">
        <input type="checkbox" id="show-edge-vectors">
        <label for="show-edge-vectors">Show Edge Vectors</label>
      </div>
      <div class="viz-control-item">
        <input type="checkbox" id="show-sign-paths" checked>
        <label for="show-sign-paths">Show Sign Paths</label>
      </div>
      <div class="viz-control-item">
        <input type="checkbox" id="show-labels" checked>
        <label for="show-labels">Show Labels</label>
      </div>
      <div class="viz-control-item">
        <input type="checkbox" id="show-in-out-markers">
        <label for="show-in-out-markers">Show Inside/Outside Markers</label>
      </div>
      <div class="viz-control-item">
        <button id="clear-viz" style="width: 100%; padding: 5px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">
          Clear All Visualizations
        </button>
      </div>
    </div>

    <!-- Buttons Container -->
    <div class="btns-left-top">
      <button id="download-btn" class="flex-center btn-download">
        <ion-icon name="cloud-download-outline"></ion-icon>
        <span>Download</span>
      </button>

      <button id="export-btn" class="flex-center btn-export">
        <ion-icon name="save-outline"></ion-icon>
        <span>Export State</span>
      </button>

      <button id="import-btn" class="flex-center btn-import">
        <ion-icon name="folder-open-outline"></ion-icon>
        <span>Import State</span>
      </button>
      
      <!-- Road Area Definition Button -->
      <button id="define-road-btn" class="flex-center" style="background: linear-gradient(135deg, #0f766e, #0d9488); width: auto; padding: 10px 15px;">
        <ion-icon name="analytics-outline"></ion-icon>
        <span>Define Road</span>
      </button>
      
      <!-- Finish Road Definition Button (hidden by default) -->
      <button id="finish-road-btn" class="flex-center" style="background: linear-gradient(135deg, #0f766e, #0d9488); width: auto; padding: 10px 15px; display: none;">
        <ion-icon name="checkmark-outline"></ion-icon>
        <span>Set Road</span>
      </button>

      <!-- Construction Area Selection -->
      <button id="select-area-btn" class="flex-center btn-select">
        <ion-icon name="crop-outline"></ion-icon>
        <span>Select Area</span>
      </button>

      <button id="finish-area-btn" class="flex-center btn-finish">
        <ion-icon name="checkmark-outline"></ion-icon>
        <span>Finish Area</span>
      </button>
      
      <!-- AI Compliance Check Button -->
      <button id="ai-check-btn" class="flex-center btn-select" style="background: linear-gradient(135deg, #4c1d95, #6b21a8);">
        <ion-icon name="shield-checkmark-outline"></ion-icon>
        <span>AI Check</span>
      </button>
      
    </div>

    <!-- Hidden file input for importing state -->
    <input type="file" id="import-input" style="display: none" accept=".json" />

    <!-- Custom Confirm Modal (Yes/No) -->
    <div id="custom-confirm-modal" class="custom-modal">
      <div class="custom-modal-content">
        <p id="custom-confirm-message"></p>
        <div class="custom-modal-buttons">
          <button id="custom-confirm-yes">
            <ion-icon name="checkmark-outline"></ion-icon> Yes
          </button>
          <button id="custom-confirm-no">
            <ion-icon name="close-outline"></ion-icon> No
          </button>
        </div>
      </div>
    </div>

    <!-- Custom Choice Modal for Marker Actions (Drag/Delete/Cancel/Rename) -->
    <div id="custom-choice-modal" class="custom-modal">
      <div class="custom-modal-content">
        <p id="custom-choice-message"></p>
        <div class="custom-modal-buttons">
          <button id="action-drag">
            <ion-icon name="brush-outline"></ion-icon> Drag Pin
          </button>
          <button id="action-delete">
            <ion-icon name="trash-outline"></ion-icon> Delete Pin
          </button>
          <button id="action-rename">
            <ion-icon name="create-outline"></ion-icon> Rename Pin
          </button>
          <button id="action-cancel">
            <ion-icon name="close-circle-outline"></ion-icon> Cancel
          </button>
        </div>
      </div>
    </div>

    <!-- Custom Rename Modal -->
    <div id="custom-rename-modal" class="custom-modal">
      <div class="custom-modal-content">
        <p id="custom-rename-message">Enter new pin name:</p>
        <input type="text" id="custom-rename-input" value="" />
        <div class="custom-modal-buttons" style="margin-top: 15px;">
          <button id="custom-rename-save">
            <ion-icon name="checkmark-outline"></ion-icon> Save
          </button>
          <button id="custom-rename-cancel">
            <ion-icon name="close-outline"></ion-icon> Cancel
          </button>
        </div>
      </div>
    </div>

    <!-- Polygon Options Modal (Same design as custom-choice modal) -->
    <div id="polygon-options-modal" class="custom-modal">
      <div class="custom-modal-content">
        <p id="polygon-options-message">Construction Area Options</p>
        <div class="custom-modal-buttons">
          <button id="polygon-unselect-btn">
            <ion-icon name="close-outline"></ion-icon> Unselect Area
          </button>
          <button id="polygon-copy-btn">
            <ion-icon name="copy-outline"></ion-icon> Copy Coordinates
          </button>
          <button id="polygon-view-btn">
            <ion-icon name="eye-outline"></ion-icon> View Coordinates
          </button>
        </div>
      </div>
    </div>
    
    <!-- Road Direction Modal -->
    <div id="road-direction-modal" class="custom-modal">
      <div class="custom-modal-content">
        <p>Select Road Direction</p>
        <div style="padding: 15px 0;">
          <div style="display: flex; justify-content: center; position: relative; width: 200px; height: 200px; margin: 0 auto;">
            <!-- Direction Compass -->
            <div style="position: absolute; width: 100%; height: 100%; border-radius: 50%; border: 2px solid #333; display: flex; justify-content: center; align-items: center;">
              <div style="position: absolute; top: 5px; left: 50%; transform: translateX(-50%);">N</div>
              <div style="position: absolute; bottom: 5px; left: 50%; transform: translateX(-50%);">S</div>
              <div style="position: absolute; left: 5px; top: 50%; transform: translateY(-50%);">W</div>
              <div style="position: absolute; right: 5px; top: 50%; transform: translateY(-50%);">E</div>
              
              <!-- Direction Arrow (will be rotated via JavaScript) -->
              <div id="direction-arrow" style="width: 80%; height: 4px; background-color: #e74c3c; transform-origin: center; transform: rotate(0deg);">
                <div style="width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 15px solid #e74c3c; position: absolute; right: -10px; top: -5px; transform: rotate(90deg);"></div>
              </div>
            </div>
          </div>
          
          <div style="display: flex; justify-content: center; margin-top: 15px;">
            <input type="range" id="direction-slider" min="0" max="359" value="0" style="width: 100%;">
          </div>
          <div style="text-align: center; margin-top: 5px;">
            Direction: <span id="direction-value">0°</span>
          </div>
        </div>
        <div class="custom-modal-buttons">
          <button id="road-direction-save">
            <ion-icon name="checkmark-outline"></ion-icon> Save Direction
          </button>
          <button id="road-direction-cancel">
            <ion-icon name="close-outline"></ion-icon> Cancel
          </button>
        </div>
      </div>
    </div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <!-- Load leaflet-image plugin -->
    <script src="https://unpkg.com/leaflet-image/leaflet-image.js"></script>
    <script>
      // Global array to store all markers
      var allMarkers = [];

      // Variables for polygon drawing
      var polygonDrawingMode = false;
      var currentPolygonPoints = [];
      var currentPolygonLayer = null;
      var drawnPolygons = []; // Array to hold all finished polygon layers
      
      // Flag to indicate if the polygon options modal is open
      var polygonModalOpen = false;
      
      // Variables for road area drawing
      var roadDrawingMode = false;
      var currentRoadPoints = [];
      var currentRoadLayer = null;
      var roadDirection = 0; // degrees (0 = North, 90 = East, etc.)
      var definedRoadArea = null; // To store the defined road area
      var roadCoordinates = []; // Store the road coordinates for path calculation
      
      // Lane information variables
      var roadLanes = 2; // Default to 2 lanes
      var laneMarkers = [];
      
      // Standard TC-2 layout specification
      const TC2_LAYOUT = {
        "workAreaCorners": {
          "topLeft": "Approach side, near centerline",
          "topRight": "Departure side, near centerline",
          "bottomLeft": "Approach side, near shoulder",
          "bottomRight": "Departure side, near shoulder"
        },
        "roadReference": {
          "trafficFlow": "Left to right",
          "laneClosed": "Right lane"
        },
        "devices": [
          {
            "name": "TC-2",
            "location": "Right shoulder (bottom), far upstream of work area"
          },
          {
            "name": "TC-3",
            "location": "Right shoulder (bottom), between TC-2 and the taper"
          },
          {
            "name": "TC-31",
            "location": "Right shoulder, near the start of the taper"
          },
          {
            "name": "Arrow Board",
            "location": "In the closed (right) lane, slightly upstream of the bottom-left corner"
          },
          {
            "name": "RB-25L",
            "location": "Right side, just past the taper, near top edge of the closed lane"
          },
          {
            "name": "TC-5R",
            "location": "At or near the bottom-left corner (approach side) of the work area"
          },
          {
            "name": "Channelizing Devices",
            "location": "Diagonal taper from bottom-right corner toward centerline"
          }
        ]
      };
      
      // Constants from Winnipeg manual
      const REGULATIONS = {
        workZoneTypes: {
          TC2: {
            name: "TC-2 Roadwork",
            description: "Short duration work zone",
            requiredSigns: ["TC-1", "TC-2", "TC-4"],
            coneSpacing: 5, // meters
            advanceWarningDistance: 100 // meters
          },
          TC3: {
            name: "TC-3 Work Area",
            description: "Extended duration work zone",
            requiredSigns: ["TC-1", "TC-3", "TC-4", "TC-36"],
            coneSpacing: 3, // meters
            advanceWarningDistance: 150 // meters
          },
          TC7: {
            name: "TC-7 Lane Closure",
            description: "Lane closure configuration",
            requiredSigns: ["TC-1", "TC-2", "TC-7", "TC-4"],
            coneSpacing: 2, // meters
            advanceWarningDistance: 200 // meters
          }
        },
        signs: {
          "TC-1": {
            name: "Construction Ahead",
            distance: 150 // meters from work zone
          },
          "TC-2": {
            name: "Roadwork",
            distance: 100 // meters from work zone
          },
          "TC-3": {
            name: "Work Area",
            distance: 75 // meters from work zone
          },
          "TC-4": {
            name: "End Construction",
            distance: 50 // meters after work zone
          },
          "TC-7": {
            name: "Lane Closed",
            distance: 75 // meters from work zone
          },
          "TC-36": {
            name: "Keep Right",
            distance: 10 // meters from work zone
          },
          "TC-63": {
            name: "Channelization Barrel",
            spacing: 5 // meters
          }
        },
        roadTypes: {
          residential: {
            speedLimit: 50, // km/h
            bufferZone: 15, // meters
            signageMultiplier: 1
          },
          collector: {
            speedLimit: 60, // km/h
            bufferZone: 20, // meters
            signageMultiplier: 1.2
          },
          arterial: {
            speedLimit: 80, // km/h
            bufferZone: 30, // meters
            signageMultiplier: 1.5
          },
          highway: {
            speedLimit: 100, // km/h
            bufferZone: 50, // meters
            signageMultiplier: 2
          }
        }
      };
      
      // Utility functions
      
      // Convert meters to lat/lon degrees (approximate)
      function metersToLatLon(meters, latitude) {
        // At equator, 1 degree = 111,319.9 meters
        // For longitude, need to take into account the latitude
        const latDegrees = meters / 111319.9;
        const lonDegrees = meters / (111319.9 * Math.cos(latitude * Math.PI / 180));
        return { latDegrees, lonDegrees };
      }
      
      // Calculate distance between two lat/lon points in meters (Haversine formula)
      function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3; // Earth's radius in meters
        const φ1 = lat1 * Math.PI / 180;
        const φ2 = lat2 * Math.PI / 180;
        const Δφ = (lat2 - lat1) * Math.PI / 180;
        const Δλ = (lon2 - lon1) * Math.PI / 180;
        
        const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                  Math.cos(φ1) * Math.cos(φ2) *
                  Math.sin(Δλ/2) * Math.sin(Δλ/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        
        return R * c;
      }
      
      // Calculate point at a given distance and bearing from start point
      function calculateDestination(startLat, startLon, distance, bearing) {
        const R = 6371e3; // Earth's radius in meters
        const δ = distance / R; // Angular distance
        const θ = bearing * Math.PI / 180; // Bearing in radians
        
        const φ1 = startLat * Math.PI / 180; // Convert to radians
        const λ1 = startLon * Math.PI / 180;
        
        const φ2 = Math.asin(
          Math.sin(φ1) * Math.cos(δ) +
          Math.cos(φ1) * Math.sin(δ) * Math.cos(θ)
        );
        
        const λ2 = λ1 + Math.atan2(
          Math.sin(θ) * Math.sin(δ) * Math.cos(φ1),
          Math.cos(δ) - Math.sin(φ1) * Math.sin(φ2)
        );
        
        // Convert back to degrees
        const destLat = φ2 * 180 / Math.PI;
        const destLon = λ2 * 180 / Math.PI;
        
        return { lat: destLat, lng: destLon };
      }
      
      // Calculate bearing between two points
      function calculateBearing(startLat, startLon, endLat, endLon) {
        const φ1 = startLat * Math.PI / 180;
        const φ2 = endLat * Math.PI / 180;
        const Δλ = (endLon - startLon) * Math.PI / 180;
        
        const y = Math.sin(Δλ) * Math.cos(φ2);
        const x = Math.cos(φ1) * Math.sin(φ2) -
                 Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
        
        let bearing = Math.atan2(y, x) * 180 / Math.PI;
        bearing = (bearing + 360) % 360; // Normalize to 0-360
        
        return bearing;
      }

      // Custom confirm function (Yes/No)
      function customConfirm(message) {
        return new Promise((resolve) => {
          const modal = document.getElementById("custom-confirm-modal");
          const messageElement = document.getElementById("custom-confirm-message");
          const yesButton = document.getElementById("custom-confirm-yes");
          const noButton = document.getElementById("custom-confirm-no");

          messageElement.textContent = message;
          modal.style.display = "flex";

          function cleanUp() {
            modal.style.display = "none";
            yesButton.removeEventListener("click", onYes);
            noButton.removeEventListener("click", onNo);
          }
          function onYes() {
            cleanUp();
            resolve(true);
          }
          function onNo() {
            cleanUp();
            resolve(false);
          }

          yesButton.addEventListener("click", onYes);
          noButton.addEventListener("click", onNo);
        });
      }

      // Custom choice function for marker actions (Drag/Delete/Cancel/Rename)
      function customChoice(message) {
        return new Promise((resolve) => {
          const modal = document.getElementById("custom-choice-modal");
          const messageElement = document.getElementById("custom-choice-message");
          const dragButton = document.getElementById("action-drag");
          const deleteButton = document.getElementById("action-delete");
          const renameButton = document.getElementById("action-rename");
          const cancelButton = document.getElementById("action-cancel");

          messageElement.textContent = message;
          modal.style.display = "flex";

          function cleanUp() {
            modal.style.display = "none";
            dragButton.removeEventListener("click", onDrag);
            deleteButton.removeEventListener("click", onDelete);
            renameButton.removeEventListener("click", onRename);
            cancelButton.removeEventListener("click", onCancel);
          }
          function onDrag() {
            cleanUp();
            resolve("drag");
          }
          function onDelete() {
            cleanUp();
            resolve("delete");
          }
          function onRename() {
            cleanUp();
            resolve("rename");
          }
          function onCancel() {
            cleanUp();
            resolve("cancel");
          }

          dragButton.addEventListener("click", onDrag);
          deleteButton.addEventListener("click", onDelete);
          renameButton.addEventListener("click", onRename);
          cancelButton.addEventListener("click", onCancel);
        });
      }

      // Custom rename function using a custom modal.
      function customRename(currentName) {
        return new Promise((resolve) => {
          const modal = document.getElementById("custom-rename-modal");
          const input = document.getElementById("custom-rename-input");
          const saveButton = document.getElementById("custom-rename-save");
          const cancelButton = document.getElementById("custom-rename-cancel");

          input.value = currentName;
          modal.style.display = "flex";

          function cleanUp() {
            modal.style.display = "none";
            saveButton.removeEventListener("click", onSave);
            cancelButton.removeEventListener("click", onCancel);
          }
          function onSave() {
            cleanUp();
            resolve(input.value);
          }
          function onCancel() {
            cleanUp();
            resolve(null);
          }
          saveButton.addEventListener("click", onSave);
          cancelButton.addEventListener("click", onCancel);
        });
      }

      // Global variables to store visualization elements so they can be toggled on/off
      var vizElements = {
        vectors: [],   // Direction vectors (road direction, sign placement, etc.)
        edges: [],     // Edge vectors of the work zone
        signPaths: [], // Paths from start point to each sign location
        labels: [],    // Text labels for vectors, signs, etc.
        markers: []    // Inside/outside markers and other markers
      };
      
      // Initialize the map with canvas rendering enabled
      var map = L.map("map", { preferCanvas: true }).setView([49.8033, -97.0823], 16);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: "© OpenStreetMap contributors",
        maxNativeZoom: 19,
        maxZoom: 22
      }).addTo(map);
      
      // Initialize visualization controls
      function initVizControls() {
        // Show/hide direction vectors
        document.getElementById('show-vectors').addEventListener('change', function() {
          vizElements.vectors.forEach(elem => {
            if (elem) {
              if (elem.options && (elem.options.color || elem.options.fillColor)) {
                // For polylines and polygons
                if (this.checked) {
                  elem.setStyle({opacity: 1, fillOpacity: 1});
                } else {
                  elem.setStyle({opacity: 0, fillOpacity: 0});
                }
              } else if (elem._icon) {
                // For markers with icons
                elem._icon.style.display = this.checked ? '' : 'none';
              }
            }
          });
        });
        
        // Show/hide edge vectors
        document.getElementById('show-edge-vectors').addEventListener('change', function() {
          vizElements.edges.forEach(elem => {
            if (elem) {
              if (elem.options && (elem.options.color || elem.options.fillColor)) {
                // For polylines and polygons
                if (this.checked) {
                  elem.setStyle({opacity: 1, fillOpacity: 1});
                } else {
                  elem.setStyle({opacity: 0, fillOpacity: 0});
                }
              } else if (elem._icon) {
                // For markers with icons
                elem._icon.style.display = this.checked ? '' : 'none';
              }
            }
          });
        });
        
        // Show/hide sign paths
        document.getElementById('show-sign-paths').addEventListener('change', function() {
          vizElements.signPaths.forEach(elem => {
            if (elem) {
              if (elem.options && (elem.options.color || elem.options.fillColor)) {
                // For polylines and polygons
                if (this.checked) {
                  elem.setStyle({opacity: 1, fillOpacity: 1});
                } else {
                  elem.setStyle({opacity: 0, fillOpacity: 0});
                }
              } else if (elem._icon) {
                // For markers with icons
                elem._icon.style.display = this.checked ? '' : 'none';
              }
            }
          });
        });
        
        // Show/hide labels
        document.getElementById('show-labels').addEventListener('change', function() {
          vizElements.labels.forEach(elem => {
            if (elem) {
              if (elem._icon) {
                // For markers with icons (labels are usually markers with divIcons)
                elem._icon.style.display = this.checked ? '' : 'none';
              } else if (elem.options && (elem.options.color || elem.options.fillColor)) {
                // For polylines and polygons (unlikely for labels but just in case)
                if (this.checked) {
                  elem.setStyle({opacity: 1, fillOpacity: 1});
                } else {
                  elem.setStyle({opacity: 0, fillOpacity: 0});
                }
              }
            }
          });
        });
        
        // Show/hide inside/outside markers
        document.getElementById('show-in-out-markers').addEventListener('change', function() {
          vizElements.markers.forEach(elem => {
            if (elem) {
              if (elem.options && (elem.options.color || elem.options.fillColor)) {
                // For circles and circleMarkers
                if (this.checked) {
                  elem.setStyle({opacity: 1, fillOpacity: 0.7});
                } else {
                  elem.setStyle({opacity: 0, fillOpacity: 0});
                }
              } else if (elem._icon) {
                // For markers with icons
                elem._icon.style.display = this.checked ? '' : 'none';
              }
            }
          });
        });
        
        // Clear all visualizations button
        document.getElementById('clear-viz').addEventListener('click', clearVizElements);
      }
      
      // Clear all visualization elements
      function clearVizElements() {
        Object.keys(vizElements).forEach(key => {
          vizElements[key].forEach(elem => {
            if (elem) {
              map.removeLayer(elem);
            }
          });
          vizElements[key] = [];
        });
      }
      
      // Initialize controls when the page loads
      document.addEventListener('DOMContentLoaded', initVizControls);

      // (Optional) Load additional GeoJSON data.
      fetch("my_plan_latlon.geojson")
        .then((response) => response.json())
        .then((data) => {
          L.geoJSON(data, {
            onEachFeature: function (feature, layer) {
              if (feature.properties && feature.properties.label) {
                layer.bindPopup(feature.properties.label);
              }
            },
          }).addTo(map);
        });

      /**
       * Creates a marker that shows its popup on hover and, on click, prompts the user for an action.
       * The marker is added to the global allMarkers array.
       */
      function createInteractiveMarker(lat, lon, popupContent) {
        var marker = L.marker([lat, lon], { draggable: false }).addTo(map);
        marker.bindPopup(popupContent);
        allMarkers.push(marker);

        // Show popup on hover.
        marker.on("mouseover", function () {
          marker.openPopup();
        });
        marker.on("mouseout", function () {
          marker.closePopup();
        });

        // On click, prompt for marker actions.
        marker.on("click", async function (e) {
          if (marker.dragging && marker.dragging.enabled()) return;
          const action = await customChoice("What would you like to do?");
          if (action === "drag") {
            marker.dragging.enable();
            alert(
              "You can now drag the marker. Once you finish dragging, it will automatically stop."
            );
            marker.once("dragend", function (e) {
              marker.dragging.disable();
              const newLatLng = marker.getLatLng();
              marker.setPopupContent(
                "Pin dropped at: " +
                  newLatLng.lat.toFixed(5) +
                  ", " +
                  newLatLng.lng.toFixed(5)
              );
            });
          } else if (action === "delete") {
            const confirmDelete = await customConfirm(
              "Are you sure you want to delete this marker?"
            );
            if (confirmDelete) {
              map.removeLayer(marker);
              allMarkers = allMarkers.filter((m) => m !== marker);
            }
          } else if (action === "rename") {
            let newName = await customRename(marker.getPopup().getContent());
            if (newName) {
              marker.setPopupContent(newName);
            }
          }
        });
        return marker;
      }

      // Function to show polygon options using the new modal.
      function showPolygonOptionsModal(polygon) {
        // Get the polygon's coordinates (using first ring).
        let latlngs = polygon.getLatLngs();
        let coords = latlngs[0].map(function (latlng) {
          return { lat: latlng.lat, lng: latlng.lng };
        });
        let coordsJSON = JSON.stringify(coords, null, 2);
        var modal = document.getElementById("polygon-options-modal");
        modal.style.display = "flex";
        polygonModalOpen = true;

        document.getElementById("polygon-unselect-btn").onclick = function (e) {
          e.stopPropagation();
          // Remove the polygon from the map.
          map.removeLayer(polygon);
          // Update the drawnPolygons array.
          drawnPolygons = drawnPolygons.filter(function (p) {
            return p !== polygon;
          });
          modal.style.display = "none";
          polygonModalOpen = false;
        };
        document.getElementById("polygon-copy-btn").onclick = function (e) {
          e.stopPropagation();
          navigator.clipboard.writeText(coordsJSON).then(function () {
            alert("Coordinates copied to clipboard.");
            modal.style.display = "none";
            polygonModalOpen = false;
          }, function (err) {
            alert("Failed to copy: " + err);
            modal.style.display = "none";
            polygonModalOpen = false;
          });
        };
        document.getElementById("polygon-view-btn").onclick = function (e) {
          e.stopPropagation();
          alert("Polygon Coordinates:\n" + coordsJSON);
          modal.style.display = "none";
          polygonModalOpen = false;
        };
      }

      // Function to open the road direction selection modal
      function openRoadDirectionModal(initialDirection = 0) {
        return new Promise((resolve) => {
          const modal = document.getElementById("road-direction-modal");
          const slider = document.getElementById("direction-slider");
          const directionValue = document.getElementById("direction-value");
          const directionArrow = document.getElementById("direction-arrow");
          const saveButton = document.getElementById("road-direction-save");
          const cancelButton = document.getElementById("road-direction-cancel");
          
          // Set initial direction if provided
          if (initialDirection !== 0) {
            // Normalize to 0-359 range
            initialDirection = Math.round(initialDirection) % 360;
            if (initialDirection < 0) initialDirection += 360;
            
            slider.value = initialDirection;
            directionValue.textContent = initialDirection + "°";
            directionArrow.style.transform = `rotate(${initialDirection}deg)`;
          }
          
          // Update direction display when slider is moved
          slider.oninput = function() {
            const direction = parseInt(this.value);
            directionValue.textContent = direction + "°";
            directionArrow.style.transform = `rotate(${direction}deg)`;
          };
          
          modal.style.display = "flex";
          
          function cleanUp() {
            modal.style.display = "none";
            saveButton.removeEventListener("click", onSave);
            cancelButton.removeEventListener("click", onCancel);
          }
          
          function onSave() {
            cleanUp();
            resolve(parseInt(slider.value));
          }
          
          function onCancel() {
            cleanUp();
            resolve(null);
          }
          
          saveButton.addEventListener("click", onSave);
          cancelButton.addEventListener("click", onCancel);
        });
      }
      
      // Function to check if a point is inside a polygon
      function isPointInPolygon(point, polygon, visualize = false) {
        const latlngs = polygon.getLatLngs()[0];
        let inside = false;
        
        for (let i = 0, j = latlngs.length - 1; i < latlngs.length; j = i++) {
          const xi = latlngs[i].lat, yi = latlngs[i].lng;
          const xj = latlngs[j].lat, yj = latlngs[j].lng;
          
          const intersect = ((yi > point.lng) !== (yj > point.lng)) &&
                            (point.lat < (xj - xi) * (point.lng - yi) / (yj - yi) + xi);
          if (intersect) inside = !inside;
        }
        
        // Optionally visualize the point we're checking
        if (visualize && document.getElementById('show-in-out-markers').checked) {
          const color = inside ? 'green' : 'red';
          const circleRadius = 3;
          
          const pointMarker = L.circle([point.lat, point.lng], {
            color: color,
            fillColor: color,
            fillOpacity: 0.7,
            radius: circleRadius
          }).addTo(map).bindTooltip(inside ? "Inside" : "Outside");
          
          // Store the marker so it can be toggled on/off
          vizElements.markers.push(pointMarker);
          
          // Also highlight the polygon we're checking against
          const originalStyle = {
            color: polygon === definedRoadArea ? 'blue' : 'red',
            weight: 2,
            opacity: 1
          };
          
          polygon.setStyle({
            color: 'yellow',
            weight: 3,
            opacity: 0.7,
            fillOpacity: 0.2
          });
          
          // Reset style after 1.5 seconds
          setTimeout(() => {
            polygon.setStyle(originalStyle);
          }, 1500);
        }
        
        return inside;
      }
      
      // Function to place a marker only if it's inside the road area
      function placeMarkerIfInRoad(lat, lon, label) {
        if (!definedRoadArea) {
          createInteractiveMarker(lat, lon, label);
          return true;
        }
        
        // Check if the marker position is inside the road area
        if (isPointInPolygon({lat, lng: lon}, definedRoadArea)) {
          createInteractiveMarker(lat, lon, label);
          return true;
        }
        
        return false; // Marker was not placed because it's outside the road
      }
      
      // Modify the map click event to support marker, polygon, and road area drawing.
      map.on("click", async function (e) {
        // If the polygon options modal is open, do nothing.
        if (polygonModalOpen) return;
        
        // If road drawing mode is active, add points to road polygon
        if (roadDrawingMode) {
          currentRoadPoints.push(e.latlng);
          
          // Add a visual marker for the point
          L.circleMarker(e.latlng, {radius: 5, color: 'blue'}).addTo(map);
          
          // Update the polygon as points are added
          if (currentRoadPoints.length > 1) {
            if (currentRoadLayer) {
              currentRoadLayer.setLatLngs(currentRoadPoints);
            } else {
              // Create the polygon and add it to the map
              currentRoadLayer = L.polygon(currentRoadPoints, { 
                color: 'blue', 
                fillOpacity: 0.2, 
                weight: 2 
              }).addTo(map);
            }
          }
          
          return; // Skip marker confirmation when drawing road
        }
        
        // If polygon drawing mode is active, add point to current polygon.
        if (polygonDrawingMode) {
          currentPolygonPoints.push(e.latlng);
          if (currentPolygonLayer) {
            currentPolygonLayer.setLatLngs(currentPolygonPoints);
          } else {
            currentPolygonLayer = L.polygon(currentPolygonPoints, { color: "red" }).addTo(map);
          }
          return; // Skip marker confirmation when drawing polygon.
        }
        
        // Otherwise, prompt to add a new marker.
        const addPin = await customConfirm("Do you want to add a new pin here?");
        if (addPin) {
          const lat = e.latlng.lat;
          const lon = e.latlng.lng;
          
          if (definedRoadArea && !isPointInPolygon({lat, lng: lon}, definedRoadArea)) {
            alert("Cannot place marker outside the defined road area. Please place markers within the road boundaries.");
          } else {
            createInteractiveMarker(
              lat,
              lon,
              "Pin dropped at: " + lat.toFixed(5) + ", " + lon.toFixed(5)
            ).openPopup();
          }
        }
      });

      
      // Function to analyze location for road type based on name/description
      function analyzeLocation(locationName) {
        // This is a simplistic analysis based on keywords - in a real AI implementation
        // this would use more sophisticated NLP or API calls to determine road classification
        const locationLower = locationName.toLowerCase();
        
        // Check for road type keywords
        if (locationLower.includes("highway") || locationLower.includes("freeway") || 
            locationLower.includes("expressway") || locationLower.includes("trans-canada")) {
          return "highway";
        } else if (locationLower.includes("ave") || locationLower.includes("boulevard") || 
                   locationLower.includes("main street") || locationLower.includes("route")) {
          return "arterial";
        } else if (locationLower.includes("road") || locationLower.includes("drive") || 
                   locationLower.includes("way") || locationLower.includes("street")) {
          return "collector";
        } else {
          return "residential"; // Default
        }
      }
      
      // Function to determine appropriate work zone type based on location analysis
      function determineWorkZoneType(locationName) {
        // Again, simplistic keyword-based analysis
        const locationLower = locationName.toLowerCase();
        
        if (locationLower.includes("construction") || locationLower.includes("build")) {
          return "TC3"; // Work Area for extended construction
        } else if (locationLower.includes("lane") || locationLower.includes("traffic") ||
                  locationLower.includes("closed")) {
          return "TC7"; // Lane Closure
        } else {
          return "TC2"; // Default - Short duration roadwork
        }
      }
      
      // Function to create a construction zone polygon programmatically
      function createConstructionZonePolygon(centerLat, centerLon, roadType, bearing = 0) {
        // Size of construction zone based on road type
        let zoneLength, zoneWidth;
        
        switch(roadType) {
          case "highway":
            zoneLength = 200;
            zoneWidth = 30;
            break;
          case "arterial":
            zoneLength = 100;
            zoneWidth = 20;
            break;
          case "collector":
            zoneLength = 75;
            zoneWidth = 15;
            break;
          default: // residential
            zoneLength = 50;
            zoneWidth = 10;
            break;
        }
        
        // Convert meters to lat/lon approximations
        const conversion = metersToLatLon(1, centerLat);
        
        // Create points for a rectangle aligned with the road
        // We'll use bearing to align it with the road direction
        const points = [];
        
        // Calculate corner points
        const halfLength = zoneLength / 2;
        const halfWidth = zoneWidth / 2;
        
        // Road direction is bearing, so rectangle sides are at bearing and bearing+90
        const pt1 = calculateDestination(centerLat, centerLon, halfLength, bearing);
        pt1.lat = calculateDestination(pt1.lat, pt1.lng, halfWidth, (bearing + 90) % 360).lat;
        pt1.lng = calculateDestination(pt1.lat, pt1.lng, halfWidth, (bearing + 90) % 360).lng;
        
        const pt2 = calculateDestination(centerLat, centerLon, halfLength, bearing);
        pt2.lat = calculateDestination(pt2.lat, pt2.lng, halfWidth, (bearing + 270) % 360).lat;
        pt2.lng = calculateDestination(pt2.lat, pt2.lng, halfWidth, (bearing + 270) % 360).lng;
        
        const pt3 = calculateDestination(centerLat, centerLon, halfLength, (bearing + 180) % 360);
        pt3.lat = calculateDestination(pt3.lat, pt3.lng, halfWidth, (bearing + 270) % 360).lat;
        pt3.lng = calculateDestination(pt3.lat, pt3.lng, halfWidth, (bearing + 270) % 360).lng;
        
        const pt4 = calculateDestination(centerLat, centerLon, halfLength, (bearing + 180) % 360);
        pt4.lat = calculateDestination(pt4.lat, pt4.lng, halfWidth, (bearing + 90) % 360).lat;
        pt4.lng = calculateDestination(pt4.lat, pt4.lng, halfWidth, (bearing + 90) % 360).lng;
        
        points.push(pt1, pt2, pt3, pt4);
        
        // Create and return the polygon
        return L.polygon(points, { color: "red" });
      }
      
      // Function to perform a search and add markers with AI analysis.
      async function performSearch(query) {
        try {
          const response = await fetch(
            "https://nominatim.openstreetmap.org/search?format=json&countrycodes=ca&q=" +
              encodeURIComponent(query)
          );
          const data = await response.json();
          if (data && data.length > 0) {
            const centerResult = data[0];
            const centerLat = parseFloat(centerResult.lat);
            const centerLon = parseFloat(centerResult.lon);
            
            // Move map to the location
            map.setView([centerLat, centerLon], 16);
            
            // AI analysis of the location
            const analyzedRoadType = analyzeLocation(centerResult.display_name);
            const analyzedWorkZoneType = determineWorkZoneType(query);
            const designate = await customConfirm(
              `AI Analysis: ${centerResult.display_name} appears to be a ${analyzedRoadType} road.\n\nDo you want to designate this area as a construction zone?`
            );
            
            if (!designate) {
              L.popup()
                .setLatLng([centerLat, centerLon])
                .setContent("Location: " + centerResult.display_name)
                .openOn(map);
              return;
            }
            
            // For road direction, check if we have a defined road area
            let useRoadDirection = roadDirection;
            
            // If we don't have a defined road direction, prompt the user to define a road area first
            if (!definedRoadArea) {
              const defineRoad = await customConfirm("For optimal placement of traffic control elements, would you like to define the road area first?");
              
              if (defineRoad) {
                // Ask for lane count before starting road drawing
                roadLanes = await promptForLaneCount();
                startRoadDrawing();
                return; // Exit this flow and let the road drawing mode take over
              } else {
                // Use a default bearing if the user doesn't want to define a road
                useRoadDirection = 45; // Default 45 degrees (NE)
              }
            }
            
            // Create construction zone polygon
            const constructionZone = createConstructionZonePolygon(centerLat, centerLon, analyzedRoadType, useRoadDirection);
            constructionZone.addTo(map);
            
            // Add click handler for the polygon
            constructionZone.on("click", function(e) {
              showPolygonOptionsModal(constructionZone);
            });
            
            // Add to the drawn polygons array
            drawnPolygons.push(constructionZone);
            
            // Ask if user wants AI to plan the construction zone
            const useAI = await customConfirm(
              `AI suggests a ${analyzedWorkZoneType} configuration for this location.\n\nDo you want to use AI to automatically plan the construction zone layout?`
            );
            
            if (useAI) {
              // Perform AI-based planning
              const createdMarkers = aiPlanConstructionZone(constructionZone, analyzedRoadType, analyzedWorkZoneType);
              
              // Create a bounding group of all elements and fit the map to it
              const allElements = [constructionZone, ...createdMarkers];
              const group = L.featureGroup(allElements);
              map.fitBounds(group.getBounds().pad(0.2));
              
              alert(`AI planning complete! Created ${createdMarkers.length} traffic control elements for a ${analyzedRoadType} road with ${REGULATIONS.workZoneTypes[analyzedWorkZoneType].name} configuration.`);
            } else {
              // Just show the basic construction zone marker
              const mainMarker = createInteractiveMarker(
                centerLat,
                centerLon,
                `Designated Construction Zone – ${REGULATIONS.workZoneTypes[analyzedWorkZoneType].name}`
              );
              mainMarker.openPopup();
            }
          } else {
            alert("Location not found!");
          }
        } catch (err) {
          console.error(err);
          alert("Error occurred while searching for location.");
        }
      }

      // Helper: Debounce function to limit API calls.
      function debounce(func, delay) {
        let timeout;
        return function (...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(this, args), delay);
        };
      }

      const locationInput = document.getElementById("location-input");
      const suggestionsDiv = document.getElementById("suggestions");

      function fetchSuggestions(query) {
        if (query.length < 3) {
          suggestionsDiv.style.display = "none";
          return;
        }
        fetch(
          "https://nominatim.openstreetmap.org/search?format=json&countrycodes=ca&q=" +
            encodeURIComponent(query)
        )
          .then((response) => response.json())
          .then((data) => {
            suggestionsDiv.innerHTML = "";
            if (data && data.length > 0) {
              suggestionsDiv.style.display = "block";
              data.forEach(function (item) {
                const suggestionItem = document.createElement("div");
                suggestionItem.className = "suggestion-item";
                suggestionItem.textContent = item.display_name;
                suggestionItem.addEventListener("click", async function () {
                  locationInput.value = "";
                  suggestionsDiv.style.display = "none";
                  const lat = parseFloat(item.lat);
                  const lon = parseFloat(item.lon);
                  
                  // Move map to the location
                  map.setView([lat, lon], 16);
                  
                  // AI analysis of the location
                  const analyzedRoadType = analyzeLocation(item.display_name);
                  const analyzedWorkZoneType = determineWorkZoneType(item.display_name);
                  
                  // Ask if the user wants to designate this area as a construction zone.
                  const designate = await customConfirm(
                    `AI Analysis: ${item.display_name} appears to be a ${analyzedRoadType} road.\n\nDo you want to designate this area as a construction zone?`
                  );
                  
                  if (!designate) {
                    L.popup()
                      .setLatLng([lat, lon])
                      .setContent("Location: " + item.display_name)
                      .openOn(map);
                    return;
                  }
                  
                  // For road direction, check if we have a defined road area
                  let useRoadDirection = roadDirection;
                  
                  // If we don't have a defined road direction, prompt the user to define a road area first
                  if (!definedRoadArea) {
                    const defineRoad = await customConfirm("For optimal placement of traffic control elements, would you like to define the road area first?");
                    
                    if (defineRoad) {
                      // Ask for lane count before starting road drawing
                      roadLanes = await promptForLaneCount();
                      startRoadDrawing();
                      return; // Exit this flow and let the road drawing mode take over
                    } else {
                      // Use a default bearing if the user doesn't want to define a road
                      useRoadDirection = 45; // Default 45 degrees (NE)
                    }
                  }
                  
                  // Create construction zone polygon
                  const constructionZone = createConstructionZonePolygon(lat, lon, analyzedRoadType, useRoadDirection);
                  constructionZone.addTo(map);
                  
                  // Add click handler for the polygon
                  constructionZone.on("click", function(e) {
                    showPolygonOptionsModal(constructionZone);
                  });
                  
                  // Add to the drawn polygons array
                  drawnPolygons.push(constructionZone);
                  
                  // Ask if user wants AI to plan the construction zone
                  const useAI = await customConfirm(
                    `AI suggests a ${analyzedWorkZoneType} configuration for this location.\n\nDo you want to use AI to automatically plan the construction zone layout?`
                  );
                  
                  if (useAI) {
                    // Perform AI-based planning
                    const createdMarkers = aiPlanConstructionZone(constructionZone, analyzedRoadType, analyzedWorkZoneType);
                    
                    // Create a bounding group of all elements and fit the map to it
                    const allElements = [constructionZone, ...createdMarkers];
                    const group = L.featureGroup(allElements);
                    map.fitBounds(group.getBounds().pad(0.2));
                    
                    alert(`AI planning complete! Created ${createdMarkers.length} traffic control elements for a ${analyzedRoadType} road with ${REGULATIONS.workZoneTypes[analyzedWorkZoneType].name} configuration.`);
                  } else {
                    // Just show the basic construction zone marker
                    const mainMarker = createInteractiveMarker(
                      lat,
                      lon,
                      `Designated Construction Zone – ${REGULATIONS.workZoneTypes[analyzedWorkZoneType].name}`
                    );
                    mainMarker.openPopup();
                  }
                });
                suggestionsDiv.appendChild(suggestionItem);
              });
            } else {
              suggestionsDiv.style.display = "none";
            }
          })
          .catch((err) => console.error(err));
      }

      locationInput.addEventListener(
        "input",
        debounce(function (e) {
          fetchSuggestions(e.target.value);
        }, 300)
      );

      document.getElementById("search-btn").addEventListener("click", function () {
        const query = locationInput.value;
        if (query) {
          performSearch(query);
          suggestionsDiv.style.display = "none";
        }
      });

      // Download map functionality.
      document.getElementById("download-btn").addEventListener("click", function () {
        leafletImage(map, function (err, canvas) {
          if (err) {
            console.error(err);
            alert("Error generating map image.");
            return;
          }
          var imgData = canvas.toDataURL("image/png");
          var link = document.createElement("a");
          link.href = imgData;
          link.download = "map.png";
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        });
      });

      // Export state: save all markers and polygons to a JSON file.
      // Function to check traffic control plan compliance with regulations
      function checkCompliance() {
        if (drawnPolygons.length === 0) {
          alert("You need to create a construction zone first.");
          return {
            isCompliant: false,
            issues: ["No construction zone defined"]
          };
        }
        
        // Issues array to track compliance problems
        const issues = [];
        let markerTypes = {};
        
        // Count different marker types
        allMarkers.forEach(marker => {
          const content = marker.getPopup() ? marker.getPopup().getContent() : "";
          const type = content.split(' ')[0]; // Simplified - just get first word
          markerTypes[type] = (markerTypes[type] || 0) + 1;
        });
        
        // Check if there are any markers at all
        if (allMarkers.length === 0) {
          issues.push("No traffic control elements placed");
        }
        
        // Check if construction zone has all required signs
        // For simplicity, we'll look for specific keywords in marker popup content
        const requiredSigns = ["Construction", "Roadwork", "End"];
        requiredSigns.forEach(sign => {
          const found = allMarkers.some(marker => {
            const content = marker.getPopup() ? marker.getPopup().getContent() : "";
            return content.includes(sign);
          });
          
          if (!found) {
            issues.push(`Missing required sign: ${sign}`);
          }
        });
        
        // Check cones/pylons placement
        if (!markerTypes["Traffic"] || markerTypes["Traffic"] < 4) {
          issues.push("Insufficient traffic cones/pylons (minimum 4 required)");
        }
        
        // Check channelization barrels
        if (!markerTypes["Channelization"] || markerTypes["Channelization"] < 1) {
          issues.push("Missing channelization barrels");
        }
        
        // Check distances between elements (simplified)
        // In a full implementation, we would check actual distances based on regulations
        
        return {
          isCompliant: issues.length === 0,
          issues: issues
        };
      }

      function exportState() {
        // Run compliance check before exporting
        const compliance = checkCompliance();
        
        var stateData = {
          markers: [],
          polygons: [],
          compliance: compliance
        };

        // Export markers.
        allMarkers.forEach(function (marker) {
          var latlng = marker.getLatLng();
          var content = marker.getPopup() ? marker.getPopup().getContent() : "";
          stateData.markers.push({
            lat: latlng.lat,
            lng: latlng.lng,
            popupContent: content
          });
        });

        // Export drawn polygons.
        drawnPolygons.forEach(function (polygon) {
          var latlngs = polygon.getLatLngs()[0]; // Assuming first ring.
          var coords = latlngs.map(function (latlng) {
            return { lat: latlng.lat, lng: latlng.lng };
          });
          stateData.polygons.push({
            coordinates: coords
          });
        });

        var dataStr = JSON.stringify(stateData, null, 2);
        var blob = new Blob([dataStr], { type: "application/json" });
        var url = URL.createObjectURL(blob);
        var a = document.createElement("a");
        a.href = url;
        a.download = "map_state.json";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        // Display compliance report
        if (!compliance.isCompliant) {
          alert(`Compliance Warning: Your traffic control plan has ${compliance.issues.length} issues that need to be addressed:\n\n` + 
                compliance.issues.join('\n'));
        } else {
          alert("Compliance Check: Your traffic control plan complies with Winnipeg regulations.");
        }
      }

      // Import state: load markers and polygons from a JSON file.
      document.getElementById("import-input").addEventListener("change", function (e) {
        var file = e.target.files[0];
        if (!file) return;
        var reader = new FileReader();
        reader.onload = function (e) {
          try {
            var stateData = JSON.parse(e.target.result);

            // Remove current markers.
            allMarkers.forEach(function (marker) {
              map.removeLayer(marker);
            });
            allMarkers = [];

            // Remove current polygons.
            drawnPolygons.forEach(function (polygon) {
              map.removeLayer(polygon);
            });
            drawnPolygons = [];

            // Re-add markers.
            if (stateData.markers) {
              stateData.markers.forEach(function (data) {
                createInteractiveMarker(data.lat, data.lng, data.popupContent);
              });
            }

            // Re-add polygons.
            if (stateData.polygons) {
              stateData.polygons.forEach(function (polygonData) {
                var polygon = L.polygon(polygonData.coordinates, { color: "red" }).addTo(map);
                // Add click listener to re-enable options.
                polygon.on("click", function (e) {
                  showPolygonOptionsModal(polygon);
                });
                drawnPolygons.push(polygon);
              });
            }
          } catch (err) {
            alert("Error loading state file: " + err);
          }
        };
        reader.readAsText(file);
      });

      // Function to provide AI recommendations for fixing compliance issues
      async function aiRecommendFixes(issues) {
        if (issues.length === 0) return;
        
        let recommendations = [];
        
        // Generate recommendations based on issue type
        issues.forEach(issue => {
          if (issue.includes("Missing required sign")) {
            const signType = issue.split(": ")[1];
            recommendations.push(`Add ${signType} sign at appropriate distance from work zone`);
          } 
          else if (issue.includes("Insufficient traffic cones")) {
            recommendations.push("Add more traffic cones around the perimeter of work zone (minimum 4)");
          }
          else if (issue.includes("Missing channelization barrels")) {
            recommendations.push("Add channelization barrels at corners of work zone");
          }
          else if (issue.includes("No construction zone")) {
            recommendations.push("Create a construction zone by using the 'Select Area' button");
          }
          else if (issue.includes("No traffic control elements")) {
            recommendations.push("Add traffic control elements using AI-assisted planning");
          }
        });
        
        // Ask user if they want AI to automatically fix the issues
        const autoFix = await customConfirm(
          `AI Recommendations:\n\n${recommendations.join('\n')}\n\nWould you like AI to automatically fix these issues?`
        );
        
        if (autoFix) {
          // For illustration, let's implement a basic auto-fix for some common issues
          
          // If no construction zone, we can't do much else
          if (issues.includes("No construction zone defined")) {
            alert("Please create a construction zone first using the 'Select Area' button.");
            return;
          }
          
          // If no markers or missing specific elements, use aiPlanConstructionZone to regenerate all elements
          if (allMarkers.length === 0 || 
              issues.some(i => i.includes("Missing required sign") || 
                               i.includes("Insufficient traffic cones") || 
                               i.includes("Missing channelization"))) {
            
            // Get the first construction zone polygon
            const constructionZone = drawnPolygons[0];
            
            // Determine road type (simplified - in real implementation, would analyze map data)
            const roadType = "residential";
            
            // Perform AI-based planning
            const createdMarkers = aiPlanConstructionZone(constructionZone, roadType, "TC2");
            
            // Create a bounding group of all elements and fit the map to it
            const allElements = [constructionZone, ...createdMarkers];
            const group = L.featureGroup(allElements);
            map.fitBounds(group.getBounds().pad(0.2));
            
            alert(`AI auto-fix complete! Added ${createdMarkers.length} traffic control elements.`);
          }
        }
      }
      
      // AI Check button functionality
      document.getElementById("ai-check-btn").addEventListener("click", async function() {
        // Run compliance check
        const compliance = checkCompliance();
        
        if (compliance.isCompliant) {
          alert("AI Check Complete: Your traffic control plan complies with Winnipeg regulations!");
        } else {
          // Call AI recommendations function
          await aiRecommendFixes(compliance.issues);
        }
      });
      document.getElementById("export-btn").addEventListener("click", exportState);
      document.getElementById("import-btn").addEventListener("click", function () {
        document.getElementById("import-input").click();
      });

      // Function to prompt for lane count
      function promptForLaneCount() {
        return new Promise((resolve) => {
          const laneCount = prompt("How many lanes does this road have? (total in both directions)", "2");
          
          // Parse and validate lane count (must be a positive integer)
          const numLanes = parseInt(laneCount);
          if (!isNaN(numLanes) && numLanes > 0) {
            resolve(numLanes);
          } else {
            alert("Please enter a valid number of lanes (positive integer).");
            resolve(2); // Default to 2 lanes if invalid input
          }
        });
      }
      
      // Enable road area drawing mode
      document.getElementById("define-road-btn").addEventListener("click", async function () {
        // If we already have a defined road, ask to confirm replacement
        if (definedRoadArea) {
          const result = await customConfirm("You already have a defined road area. Do you want to replace it?");
          if (result) {
            // Ask for lane count before starting road drawing
            roadLanes = await promptForLaneCount();
            startRoadDrawing();
          }
        } else {
          // Ask for lane count before starting road drawing
          roadLanes = await promptForLaneCount();
          startRoadDrawing();
        }
      });
      
      // Function to start road drawing mode
      function startRoadDrawing() {
        // Exit polygon drawing mode if active
        if (polygonDrawingMode) {
          polygonDrawingMode = false;
          document.getElementById("finish-area-btn").style.display = "none";
        }
        
        // Start road drawing mode
        roadDrawingMode = true;
        currentRoadPoints = [];
        
        // Remove existing road layer if there is one
        if (currentRoadLayer) {
          map.removeLayer(currentRoadLayer);
          currentRoadLayer = null;
        }
        
        // If there's a defined road area, remove it
        if (definedRoadArea) {
          map.removeLayer(definedRoadArea);
          definedRoadArea = null;
        }
        
        document.getElementById("define-road-btn").style.display = "none";
        document.getElementById("finish-road-btn").style.display = "inline-flex";
        
        alert(`Road definition mode activated for a ${roadLanes}-lane road. Click on the map to add points defining the road area boundary. Click 'Set Road' when finished.`);
      }
      
      // Event listener for the finish road button
      document.getElementById("finish-road-btn").addEventListener("click", async function() {
        if (currentRoadPoints.length < 3) {
          alert("A road area requires at least 3 points.");
          return;
        }
        
        // Calculate the average direction based on all segments
        let totalDirection = 0;
        let segmentCount = 0;
        
        // Store all coordinates for future reference
        roadCoordinates = [...currentRoadPoints];
        
        // Calculate direction from all line segments
        for (let i = 0; i < currentRoadPoints.length - 1; i++) {
          const p1 = currentRoadPoints[i];
          const p2 = currentRoadPoints[i + 1];
          
          const segmentBearing = calculateBearing(p1.lat, p1.lng, p2.lat, p2.lng);
          totalDirection += segmentBearing;
          segmentCount++;
        }
        
        // Also include the segment from last to first point to close the loop
        if (currentRoadPoints.length > 2) {
          const first = currentRoadPoints[0];
          const last = currentRoadPoints[currentRoadPoints.length - 1];
          
          const closingBearing = calculateBearing(last.lat, last.lng, first.lat, first.lng);
          totalDirection += closingBearing;
          segmentCount++;
        }
        
        // Calculate average direction
        const avgDirection = segmentCount > 0 ? totalDirection / segmentCount : 0;
        
        // Prompt user to select the road direction, with the average direction as default
        const selectedDirection = await openRoadDirectionModal(avgDirection);
        if (selectedDirection !== null) {
          roadDirection = selectedDirection;
          definedRoadArea = currentRoadLayer;
          
          // Exit road drawing mode
          roadDrawingMode = false;
          document.getElementById("finish-road-btn").style.display = "none";
          document.getElementById("define-road-btn").style.display = "inline-flex";
          
          // Style the road layer to indicate it's now defined
          currentRoadLayer.setStyle({color: '#0d9488', fillOpacity: 0.3, weight: 3});
          
          // Add a label to the road including lane count
          const center = currentRoadLayer.getBounds().getCenter();
          L.marker(center, {
            icon: L.divIcon({
              className: 'road-label',
              html: `<div style="background: rgba(255,255,255,0.7); padding: 3px; border-radius: 3px; color: #0d9488; font-weight: bold;">
                      ${roadLanes}-Lane Road | Direction: ${roadDirection}°
                     </div>`,
              iconSize: [150, 20],
              iconAnchor: [75, 10]
            })
          }).addTo(map);
          
          // Create popup to show the road information
          L.popup()
            .setLatLng(center)
            .setContent(`${roadLanes}-lane road defined with direction: ${roadDirection}°`)
            .openOn(map);
            
          currentRoadPoints = [];
          
          alert(`${roadLanes}-lane road area defined successfully. The traffic control elements will be placed within this area.`);
        } else {
          // User canceled, stay in road drawing mode
          alert("Road direction selection canceled. Continue adding points or click 'Set Road' when finished.");
        }
      });
      
      // NEW: Enable polygon drawing mode.
      document.getElementById("select-area-btn").addEventListener("click", function () {
        // Check if we have a defined road area
        if (!definedRoadArea) {
          customConfirm("No road area defined yet. It's recommended to define a road area first. Do you want to define a road area now?").then(function(result) {
            if (result) {
              startRoadDrawing();
            } else {
              startPolygonDrawing();
            }
          });
        } else {
          startPolygonDrawing();
        }
      });
      
      // Function to start polygon drawing mode
      function startPolygonDrawing() {
        polygonDrawingMode = true;
        currentPolygonPoints = [];
        
        if (currentPolygonLayer) {
          map.removeLayer(currentPolygonLayer);
          currentPolygonLayer = null;
        }
        
        alert(
          "Polygon drawing mode activated. Click on the map to add polygon vertices. When finished, click the 'Finish Area' button."
        );
        
        document.getElementById("finish-area-btn").style.display = "inline-flex";
      }

      // Function to automatically plan a construction zone based on AI analysis
      function aiPlanConstructionZone(polygon, roadType = "residential", workZoneType = "TC2") {
        // Get the polygon bounds to find its center
        const bounds = polygon.getBounds();
        const center = bounds.getCenter();
        
        // Get the corners of the work area (polygon)
        const polygonPoints = polygon.getLatLngs()[0];
        
        // Use the road direction if defined
        let bearing = roadDirection;
        if (bearing === 0 && polygonPoints.length > 1) {
          bearing = calculateBearing(
            polygonPoints[0].lat, 
            polygonPoints[0].lng, 
            polygonPoints[1].lat, 
            polygonPoints[1].lng
          );
        }
        
        // Get appropriate regulations for the work zone and road type
        const zoneConfig = REGULATIONS.workZoneTypes[workZoneType];
        const roadConfig = REGULATIONS.roadTypes[roadType];
        
        // Arrays to track markers
        const newMarkers = [];
        const placedMarkers = [];
        
        // Function to place marker only if inside road area
        function tryPlaceMarker(lat, lng, label) {
          // Check if inside the road area if one is defined
          if (definedRoadArea) {
            // Use the visualize parameter to debug placement issues
            const pointIsInRoad = isPointInPolygon({lat, lng}, definedRoadArea, true);
            
            if (pointIsInRoad) {
              const marker = createInteractiveMarker(lat, lng, label);
              placedMarkers.push(marker);
              return marker;
            }
            // Add a debug message when a marker can't be placed
            console.log(`Can't place ${label} at [${lat}, ${lng}] - outside road area`);
            return null;
          } else {
            // If no road area defined, place marker without restrictions
            const marker = createInteractiveMarker(lat, lng, label);
            placedMarkers.push(marker);
            return marker;
          }
        }
        
        // Use vector-based approach for sign placement
        console.log("Using vector-based approach for sign placement");
        
        // 1. Create a vector from the direction specified by the user
        // Convert degrees to radians for calculations
        // In mapping, 0° is north, 90° is east, etc., but in vector math:
        // - x increases to the east (90°)
        // - y increases to the north (0°)
        const bearingRad = (bearing * Math.PI) / 180;
        const v1 = {
          // For a bearing angle, x is sin(angle) and y is cos(angle)
          // But we need to negate y because map coordinates increase southward
          x: Math.sin(bearingRad),
          y: -Math.cos(bearingRad)  // Negative because y increases southward on maps
        };
        
        // 2. Analyze the work zone polygon to find the edge that best aligns with the road direction
        // Extract actual corner points from the polygon
        const corners = polygonPoints;
        
        // Need at least 3 points to form a polygon
        if (corners.length < 3) {
          console.error("Work zone doesn't have enough points");
          
          // Add label at center and return
          const mainMarker = tryPlaceMarker(
            center.lat, center.lng, 
            `Work Zone (${roadLanes} lanes) - Need more points`
          );
          if (mainMarker) newMarkers.push(mainMarker);
          
          return newMarkers;
        }
        
        // 3. Compute vectors between adjacent corners
        const vectors = [];
        for (let i = 0; i < corners.length; i++) {
          const p1 = corners[i];
          const p2 = corners[(i + 1) % corners.length];
          
          // Create a vector from p1 to p2
          const vector = {
            p1: p1,
            p2: p2,
            dx: p2.lng - p1.lng,
            dy: p2.lat - p1.lat
          };
          
          // Normalize the vector
          const length = Math.sqrt(vector.dx * vector.dx + vector.dy * vector.dy);
          vector.dx = vector.dx / length;
          vector.dy = vector.dy / length;
          
          vectors.push(vector);
        }
        
        // 4. Find the vector that best aligns with v1 using dot product (cosine similarity)
        let bestAlignment = -Infinity;
        let bestVector = null;
        let bestVectorIndex = -1;
        
        vectors.forEach((vector, index) => {
          // Calculate dot product (v1 • v2)
          const dotProduct = (v1.x * vector.dx) + (v1.y * vector.dy);
          
          // We actually want the vector aligned with or opposite to v1
          const alignment = Math.abs(dotProduct);
          
          if (alignment > bestAlignment) {
            bestAlignment = alignment;
            bestVector = vector;
            bestVectorIndex = index;
          }
        });
        
        // Marker to show the work area
        const workZoneMarker = tryPlaceMarker(
          center.lat, center.lng, 
          `Work Zone (${roadConfig.speedLimit} km/h, ${roadLanes} lanes)`
        );
        if (workZoneMarker) newMarkers.push(workZoneMarker);
        
        // If we found a well-aligned vector
        if (bestVector) {
          // Determine the actual direction of traffic based on the sign convention
          // dot product > 0 means vectors point in similar direction
          const dotProduct = (v1.x * bestVector.dx) + (v1.y * bestVector.dy);
          
          // Determine the starting point for sign placement
          // We'll use the second point (p2) of the best vector as our reference
          const startPoint = bestVector.p2;
          
          // Function to create an arrow for vector visualization
          function createArrow(startLat, startLng, vector, length, color, name, type = 'vector') {
            // Calculate the end point based on the vector direction
            const endLat = startLat + vector.y * length;
            const endLng = startLng + vector.x * length;
            
            // Create the line
            const line = L.polyline([
              [startLat, startLng],
              [endLat, endLng]
            ], {color: color, weight: 4}).addTo(map);
            
            // Create arrowhead
            const headLength = length * 0.2;
            const headAngle = Math.atan2(vector.y, vector.x);
            
            // Calculate arrowhead points
            const head1Lat = endLat - headLength * Math.cos(headAngle - Math.PI/6);
            const head1Lng = endLng - headLength * Math.sin(headAngle - Math.PI/6);
            
            const head2Lat = endLat - headLength * Math.cos(headAngle + Math.PI/6);
            const head2Lng = endLng - headLength * Math.sin(headAngle + Math.PI/6);
            
            // Draw arrowhead as a polygon
            const arrowhead = L.polygon([
              [endLat, endLng],
              [head1Lat, head1Lng],
              [head2Lat, head2Lng]
            ], {color: color, fillColor: color, fillOpacity: 1}).addTo(map);
            
            // Add label
            const label = L.marker([startLat, startLng], {
              icon: L.divIcon({
                className: 'vector-label',
                html: `<div style="background: rgba(255,255,255,0.8); padding: 3px; border-radius: 3px; color: ${color}; font-weight: bold;">${name}</div>`,
                iconSize: [150, 20],
                iconAnchor: [0, 10]
              })
            }).addTo(map);
            
            // Store created elements in the appropriate arrays for toggling visibility
            if (type === 'vector') {
              vizElements.vectors.push(line);
              vizElements.vectors.push(arrowhead);
              vizElements.labels.push(label);
            } else if (type === 'edge') {
              vizElements.edges.push(line);
              vizElements.edges.push(arrowhead);
              vizElements.labels.push(label);
            }
            
            return {line, arrowhead, label};
          }
          
          // Scale for better visualization (adjust if needed)
          const vectorScale = 0.003;
          
          // 1. Visualize the road direction vector (v1) - WHITE
          createArrow(center.lat, center.lng, v1, vectorScale, 'white', 'Road Direction', 'vector');
          
          // 2. Visualize the best aligned vector - BLUE
          const bestVectorDir = {
            x: bestVector.dx,
            y: bestVector.dy
          };
          createArrow(bestVector.p1.lat, bestVector.p1.lng, bestVectorDir, vectorScale, 'blue', 'Best Aligned Edge', 'vector');
          
          // 3. Calculate perpendicular vector for sign placement - RED
          // Make sure the perpendicular vector points toward the road area (not away from it)
          // We need to check both possible perpendicular vectors
          const perpVector1 = {
            x: -bestVector.dy, // Perpendicular option 1: (-dy, dx)
            y: bestVector.dx
          };
          
          const perpVector2 = {
            x: bestVector.dy, // Perpendicular option 2: (dy, -dx)
            y: -bestVector.dx
          };
          
          // Test points in both directions to see which is more likely to be in the road
          const testDist = 0.0005; // Small test distance
          const testPoint1 = {
            lat: startPoint.lat + perpVector1.y * testDist,
            lng: startPoint.lng + perpVector1.x * testDist
          };
          
          const testPoint2 = {
            lat: startPoint.lat + perpVector2.y * testDist,
            lng: startPoint.lng + perpVector2.x * testDist
          };
          
          // Determine which perpendicular vector to use
          let perpVector = perpVector1;
          let perpColorName = 'red';
          
          // If we have a road area, check which point is inside it
          if (definedRoadArea) {
            const isPoint1InRoad = isPointInPolygon(testPoint1, definedRoadArea);
            const isPoint2InRoad = isPointInPolygon(testPoint2, definedRoadArea);
            
            // If one point is in the road and the other isn't, choose the one in the road
            if (isPoint1InRoad && !isPoint2InRoad) {
              perpVector = perpVector1;
              console.log("Using perpendicular vector 1 (inside road)");
            } else if (!isPoint1InRoad && isPoint2InRoad) {
              perpVector = perpVector2;
              perpColorName = 'darkred';
              console.log("Using perpendicular vector 2 (inside road)");
            } else {
              // If both or neither are in the road, use dot product with road direction
              // to determine which is more aligned with the intended direction
              const dot1 = (perpVector1.x * v1.x) + (perpVector1.y * v1.y);
              const dot2 = (perpVector2.x * v1.x) + (perpVector2.y * v1.y);
              
              if (Math.abs(dot1) < Math.abs(dot2)) {
                perpVector = perpVector1;
                console.log("Using perpendicular vector 1 (better aligned)");
              } else {
                perpVector = perpVector2;
                perpColorName = 'darkred';
                console.log("Using perpendicular vector 2 (better aligned)");
              }
            }
          }
          
          // Visualize the chosen perpendicular vector
          createArrow(startPoint.lat, startPoint.lng, perpVector, vectorScale, perpColorName, 'Sign Placement Direction', 'vector');
          
          // Show the alternative perpendicular vector in a lighter color
          const altPerpVector = (perpVector === perpVector1) ? perpVector2 : perpVector1;
          createArrow(startPoint.lat, startPoint.lng, altPerpVector, vectorScale * 0.5, 'pink', 'Alternative Direction', 'vector');
          
          // Update the signDirRad and signDirDeg to match our chosen perpendicular vector
          const signDirRad = Math.atan2(perpVector.y, perpVector.x);
          const signDirDeg = (signDirRad * 180 / Math.PI + 360) % 360;
          
          // Skip the original signDirRad calculation which will be overwritten
          
          // 4 & 5. Visualize other vectors (not best aligned) in gray
          vectors.forEach((vector, index) => {
            if (index !== bestVectorIndex) {
              const grayVector = {
                x: vector.dx,
                y: vector.dy
              };
              createArrow(vector.p1.lat, vector.p1.lng, grayVector, vectorScale * 0.75, '#888888', `Edge ${index+1}`, 'edge');
            }
          });
          
          // Calculate the spacing between signs (evenly spaced)
          const totalSignDistance = 150; // Place signs over 150 meters
          const numSigns = 4; // Four signs to place: TC-63, RB-25L, TC-5R, TC-2
          const signSpacing = totalSignDistance / (numSigns - 1);
          
          // We already calculated signDirRad and signDirDeg above using the perpendicular vector
          
          // Sign placements in the specified order
          const signs = [
            { name: "TC-63", label: "Channelization Barrel", distance: 0 },
            { name: "RB-25L", label: "Keep Left Sign", distance: signSpacing },
            { name: "TC-5R", label: "Barricade - Right Corner", distance: signSpacing * 2 },
            { name: "TC-2", label: "Roadwork Sign", distance: signSpacing * 3 }
          ];
          
          // Color-code sign placement for visualization
          const signColors = ['purple', 'orange', 'cyan', 'magenta'];
          
          // Place each sign with visualizations
          signs.forEach((sign, index) => {
            const signPoint = calculateDestination(
              startPoint.lat, startPoint.lng,
              sign.distance, signDirDeg
            );
            
            // Create an arrow for each sign placement
            const signArrow = L.polyline([
              [startPoint.lat, startPoint.lng],
              [signPoint.lat, signPoint.lng]
            ], {color: signColors[index], weight: 3}).addTo(map);
            
            // Add to signPaths array for toggling visibility
            vizElements.signPaths.push(signArrow);
            
            // Add a prominent marker to show exactly where the sign would be placed
            const signLocationMarker = L.circleMarker([signPoint.lat, signPoint.lng], {
              color: 'black',
              fillColor: signColors[index],
              fillOpacity: 0.8,
              radius: 8,
              weight: 2
            }).addTo(map).bindTooltip(`${sign.name} placement point`);
            
            // Add to markers array
            vizElements.markers.push(signLocationMarker);
            
            // Add a label for the sign
            const signLabel = L.marker([signPoint.lat, signPoint.lng], {
              icon: L.divIcon({
                className: 'sign-label',
                html: `<div style="background: rgba(255,255,255,0.9); padding: 5px; border-radius: 5px; border: 2px solid ${signColors[index]}; color: black; font-weight: bold;">${sign.name} - ${sign.label}<br>${Math.round(sign.distance)}m from start</div>`,
                iconSize: [200, 40],
                iconAnchor: [100, 40]
              })
            }).addTo(map);
            
            // Add to labels array
            vizElements.labels.push(signLabel);
            
            // Visualize the inside/outside status of this point
            if (definedRoadArea) {
              // This will add visual indicators (green/red circles) for each point
              const isInsideRoad = isPointInPolygon({lat: signPoint.lat, lng: signPoint.lng}, definedRoadArea, true);
              console.log(`${sign.name} is ${isInsideRoad ? 'INSIDE' : 'OUTSIDE'} road area`);
            }
            
            // Try to place the actual marker
            const signMarker = tryPlaceMarker(
              signPoint.lat, signPoint.lng,
              `${sign.name} - ${sign.label} (${Math.round(sign.distance)}m)`
            );
            
            if (signMarker) {
              newMarkers.push(signMarker);
              // Add custom class to the marker for visibility
              const icon = signMarker.getIcon();
              const newIcon = L.icon({
                iconUrl: icon.options.iconUrl,
                iconSize: [30, 45], // Make it larger
                iconAnchor: [15, 45],
                popupAnchor: [0, -45],
                className: 'highlighted-marker'
              });
              signMarker.setIcon(newIcon);
            } else {
              // If marker couldn't be placed, show a clear warning
              const warningMarker = L.marker([signPoint.lat, signPoint.lng], {
                icon: L.divIcon({
                  className: 'warning-label',
                  html: `<div style="background: rgba(255,0,0,0.9); padding: 5px; border-radius: 5px; color: white; font-weight: bold;">⚠️ ${sign.name} - Outside Road Area</div>`,
                  iconSize: [170, 40],
                  iconAnchor: [85, 20]
                })
              }).addTo(map);
              
              // Add to labels array
              vizElements.labels.push(warningMarker);
            }
          });
          
          // Place markers at each corner of the work zone for clarity
          corners.forEach((corner, index) => {
            const cornerMarker = tryPlaceMarker(
              corner.lat, corner.lng,
              `Corner ${index + 1}${index === bestVectorIndex ? " (Start)" : ""}`
            );
            
            if (cornerMarker) newMarkers.push(cornerMarker);
          });
          
          // Add additional cones around the work zone perimeter
          const coneSpacing = zoneConfig.coneSpacing;
          
          // Place cones around the construction zone perimeter
          for (let i = 0; i < polygonPoints.length; i++) {
            const p1 = polygonPoints[i];
            const p2 = polygonPoints[(i + 1) % polygonPoints.length];
            
            // Calculate distance between points
            const segmentDistance = calculateDistance(p1.lat, p1.lng, p2.lat, p2.lng);
            const segmentBearing = calculateBearing(p1.lat, p1.lng, p2.lat, p2.lng);
            
            // Determine number of cones for this segment
            const numCones = Math.max(1, Math.floor(segmentDistance / coneSpacing));
            
            // Place cones along the segment
            for (let j = 0; j <= numCones; j++) {
              // Skip the start point of segments after the first to avoid duplicates
              if (j === 0 && i > 0) continue;
              
              const distance = j * (segmentDistance / numCones);
              const conePoint = calculateDestination(p1.lat, p1.lng, distance, segmentBearing);
              
              const coneMarker = tryPlaceMarker(
                conePoint.lat, 
                conePoint.lng, 
                "Traffic Cone"
              );
              
              if (coneMarker) {
                newMarkers.push(coneMarker);
              }
            }
          }
        }
        
        // Update the allMarkers array
        allMarkers = allMarkers.concat(placedMarkers);
        
        // Return the array of created markers
        return newMarkers;
      }
      
      // NEW: Finish drawing polygon.
      document.getElementById("finish-area-btn").addEventListener("click", async function () {
        if (currentPolygonPoints.length < 3) {
          alert("A polygon requires at least 3 points.");
          return;
        }
        polygonDrawingMode = false;
        this.style.display = "none";
        const finishedPolygon = currentPolygonLayer;
        
        // Add click handler for the polygon
        finishedPolygon.on("click", function (e) {
          showPolygonOptionsModal(finishedPolygon);
        });
        
        // Add to the drawn polygons array
        drawnPolygons.push(finishedPolygon);
        
        // Ask user if they want AI-assisted planning
        const useAI = await customConfirm("Do you want to use AI to automatically plan the construction zone layout?");
        
        if (useAI) {
          // First, prompt for road type selection
          const roadTypes = Object.keys(REGULATIONS.roadTypes);
          let roadTypePrompt = "Select road type:\n";
          roadTypes.forEach((type, index) => {
            roadTypePrompt += `${index + 1}. ${type} (${REGULATIONS.roadTypes[type].speedLimit} km/h)\n`;
          });
          
          const roadTypeIndex = parseInt(prompt(roadTypePrompt, "1")) - 1;
          const selectedRoadType = roadTypes[roadTypeIndex >= 0 && roadTypeIndex < roadTypes.length ? roadTypeIndex : 0];
          
          // Then, prompt for work zone type selection
          const workZoneTypes = Object.keys(REGULATIONS.workZoneTypes);
          let workZonePrompt = "Select work zone type:\n";
          workZoneTypes.forEach((type, index) => {
            workZonePrompt += `${index + 1}. ${REGULATIONS.workZoneTypes[type].name} - ${REGULATIONS.workZoneTypes[type].description}\n`;
          });
          
          const workZoneIndex = parseInt(prompt(workZonePrompt, "1")) - 1;
          const selectedWorkZoneType = workZoneTypes[workZoneIndex >= 0 && workZoneIndex < workZoneTypes.length ? workZoneIndex : 0];
          
          // Perform AI-based planning based on selected options
          const createdMarkers = aiPlanConstructionZone(finishedPolygon, selectedRoadType, selectedWorkZoneType);
          
          // Create a bounding group of all elements and fit the map to it
          const allElements = [finishedPolygon, ...createdMarkers];
          const group = L.featureGroup(allElements);
          map.fitBounds(group.getBounds().pad(0.2));
          
          alert(`AI planning complete! Created ${createdMarkers.length} traffic control elements for a ${selectedRoadType} road with ${REGULATIONS.workZoneTypes[selectedWorkZoneType].name} configuration.`);
        } else {
          alert("Construction area created. Click on it to view options.");
        }
        
        // Reset polygon drawing state
        currentPolygonPoints = [];
        currentPolygonLayer = null;
      });
    </script>
  </body>
</html>
